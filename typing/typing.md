# Аннотации типов
Python динамически типизирован, но начиная с версии 3.5 поддерживает аннотации типов (type hints) — метки типов для переменных и функций.

На выполнение программы они не влияют — используются для статического анализа (IDE, mypy, Pyright и др.) и повышения читаемости.

**Аннотации для переменных**

```py
age: int = 42
flag: bool = True

# допустимо не указывать значение, но это не объявление переменной
name: str
# print(name)  # ошибка:  переменная name не объявлена!
 
x: int = "ha-ha"        # допустимо, т.к. аннотация игнорируется компилятором; 
                        # но это вносит путаницу в код со стороны программиста
                        # 
```

**Аннотации для функций**

```py
def foo(a: int, b: str) -> bool:
    ...
```


**Аннотации для базовых коллекций**
```py
list[int]
tuple[str, int]
dict[str, int]
set[float]
```

До Python 3.9 для аннотации типов стандартных коллекций использовался пакет `typing`. Сейчас такой код устарел:
```py
from typing import List, Tuple, Dict, Set       # устарело
List[int], Tuple[str, int], Dict[str, int], Set[float]
```

**Аналог Optional**
```py
# data будет иметь тип либо int либо None
data: int | None
```

Однако typing полезен для **специальных типов**:

```py
# тип для функций и предикатов
from typing import Callable
f: Callable[[int, str], bool]   # функция вида: f( int, str) -> bool 
```


#### Литералы
Позволяет указать конкретные литералы в качестве допустимых значений (например, фиксированные строки или числа)

```py
from typing import Literal
def move(direction: Literal["up", "down", "left", "right"]): ...
```


#### Обобщённые типы

```py
# произвольный тип
from typing import Any
variable: Any
```



`TypeVar` — нужен для описания обобщённых (generic) функций и классов (в стиле <T>). Например, без него нельзя выразить: функция возвращает тот же тип, что и принимает.

```py
T = TypeVar("T")
def id(x: T) -> T: ...
```

`Generic` задаёт тип-параметр для другого типа.

Например, класс содержит переменную типа T
```py
from typing import Generic

class Box(Generic[T]):
    value: T
```



`Protocol` — своего рода интерфейс.
Через него определяется какой интерфейс должен быть у объекта (методы + атрибуты).

```py
from typing import Protocol

class Quacker(Protocol):
    def quack(self) -> str: ...
```
Любой объект с методом `quack() -> str` соответствует этому типу.
Если объект имеет этот метод — считается подходящим без наследования
