# Словарь (dict)

Словарь (`dict`) — ассоциативный тип данных в Python, который хранит пары «ключ → значение». 

Хорошо подходит для хранения структурированных данных (json-объектов, конфигураций и т.п.). Основан на хеш-таблице. 

## Основные свойства

* `dict` — изменяемый (mutable) контейнер для пар «ключ: значение».
* Ключи должны быть **хэшируемыми** (immutable): `str`, `int`, `float`, `tuple` (если элементы хэшируемы) и т.д. Нельзя использовать `list`, `dict` или другие изменяемые объекты как ключи.
* Начиная с Python 3.7 словари сохраняют порядок вставки.
* Сложность операций. Доступ по ключу, вставка и удаление в среднем - O(1)

## Примеры

```python
# создание
d = {}                    # пустой словарь
d2 = dict()               # пустой словарь
d3 = {"a": 1, "b": 2}     # через словарный литерал

# доступ
v = d3["a"]               # raise KeyError если нет ключа
v2 = d3.get("c")          # None если нет ключа
v3 = d3.get("c", 0)       # значение по умолчанию если нет ключа

# добавление / обновление
d3["c"] = 3

# удаление
val = d3.pop("b")         # возвращает удалённое значение, raise KeyError если нет
val = d3.pop("x", None)   # безопасно
d3.popitem()              # удаляет и возвращает пару (последнюю вставленную)

# проверка наличия ключа
if "a" in d3:
    ...
```

## Часто используемые Методы

* `d.keys()`, `d.values()`, `d.items()` — представления (view) ключей, значений и пар. Представление — тип данных, который позволяет получить доступ к данным или их части в удобном виде без создания копии. 
* `d.update(other)` — обновить словарь `d` элементами из словаря `other`.
* `d.clear()` — очистить словарь.
* `dict.fromkeys(iterable, value=None)` — создать словарь со всеми ключами из итерируемого и одинаковым значением.
* `d.setdefault(key, default)` — вернуть `d[key]`, если нет — вставить и вернуть `default`.
* `copy` и deepcopy: `d.copy()` — поверхностная копия; для вложенных структур применять `copy.deepcopy()`.


## Перебор (итераторы)

```python
for k in d:
    # перебирает ключи
for k in d.keys():
    ...
for v in d.values():
    ...
for k, v in d.items():
    # перебор пар
```

Если требуется удалять элементы во время перебора, нельзя изменять словарь прямо в процессе итерации по его представлению — сначала скопировать ключи: `for k in list(d): ...`.


## dict comprehension

```python
squares = {i: i*i for i in range(5)}   # {0:0, 1:1, ...}
# фильтрация
d_filtered = {k: v for k, v in d.items() if v is not None}
```

## Слияние словарей

* Python 3.9+: `c = a | b` (новый словарь); `a |= b` (in-place).
* Универсально: `c = {**a, **b}` — создаёт новый словарь, ключи из `b` переопределят `a`.


## Вложенные словари и доступ к полям JSON

JSON-объекты при `json.loads()` преобразуются в `dict` (и списки). Частые операции:

* доступ:

```python
import json
obj = json.loads(json_text)
val = obj.get("a", {}).get("b", {}).get("c")
```

* Для удобства работы с глубокими путями можно написать вспомогательную функцию или использовать `dict.get` с проверкой типов.


### Пример развёртывание (flatten) вложенного словаря

```python
def flatten(d, parent_key='', sep='.'):
    items = {}
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.update(flatten(v, new_key, sep=sep))
        else:
            items[new_key] = v
    return items
```



## Полезные коллекции для практики

* `collections.defaultdict(default_factory)` — автоматически создаёт значение при обращении к отсутствующему ключу (удобно для группировок, счётчиков списков и т.п.).
* `collections.Counter` — специализирован для подсчёта элементов.
* `collections.OrderedDict` — в современных версиях редко нужен, т. к. обычный `dict` сохраняет порядок, но у `OrderedDict` есть специфические методы.



## Частые паттерны в ML / парсинге JSON

* **Фичи в виде словаря**. признаки часто формируются как `{"age": 34, "city": "Moscow", "has_car": True}`. Для передачи в:
  * DataFrame: `pandas.DataFrame.from_records(list_of_dicts)`.
  * `sklearn.feature_extraction.DictVectorizer` — преобразует категориальные/числовые признаки в векторы (one-hot + числовые).
* **Отсутствующие ключи**: используйте `.get(key, default)` или `defaultdict`/`setdefault` для явной обработки.
* **Нормализация имен признаков**. При объединении данных от разных источников заранее нормализовать ключи (нижний регистр, замена пробелов и т.п.), чтобы избежать рассредоточения признаков.
* **Память**. Словари занимают значительно больше памяти, чем компактные структуры (numpy). Для больших наборов признаков задуматься о хранении в `numpy`/`pandas` или об использовании sparse-представлений.


## Копирование и вложенные структуры

* `d.copy()` — поверхностная копия: значения (если это объекты) остаются теми же ссылками.
* При вложенных словарях для полной независимости использовать `copy.deepcopy(d)`.

## Производительность и ограничения

* Поиск/вставка: амортизированно O(1). Итерация по всем элементам O(n).
* Большие словари — высокая нагрузка по памяти; в задачах ML для числовых данных лучше `numpy`/`pandas`.
* Чтение из словаря потоко-безопасно; одновременные модификации из разных потоков могут привести к ошибкам/коррупции — использовать синхронизацию.



## Примеры

1. Подсчёт встречаемости слов:

```python
from collections import Counter
words = ["a","b","a","c","a"]
cnt = Counter(words)   # Counter({'a':3, 'b':1, 'c':1})
```

2. Группировка по ключу:

```python
from collections import defaultdict
groups = defaultdict(list)
for item in records:
    groups[item["category"]].append(item)
```

3. Безопасное обновление счётчика:

```python
d = {}
d["x"] = d.get("x", 0) + 1
# или с defaultdict: counts = defaultdict(int); counts[key] += 1
```



## Словарь и JSON

Словарь -> JSON строка
```py
import json

data = {
    "city": "Amsterdam",
    "temperature": 18.5,
    "humidity": 72,
    "sensors": ["BME280", "MQ135"],
    "active": True
}

json_str = json.dumps(data, ensure_ascii=False, indent=4)
# ensure_ascii=False - для корректной обработки Юникода
print(json_str)
```

Результат:
```JSON
{
    "city": "Chita",
    "temperature": -18.5,
    "humidity": 12,
    "sensors": [
        "BME280",
        "MQ135"
    ],
    "active": true
}
```


JSON -> словарь

```py
json_text = '''
{
  "user": {
    "id": 123,
    "name": "Ivan",
    "tags": ["student", "researcher"]
  },
  "status": "alive"
}
'''

data = json.loads(json_text)

print(type(data))         # <class 'dict'>
print(data["user"]["name"])  # Ivan
print(data["user"]["tags"][0])  # student
```


## Распаковка словаря в фактические аргументы функции и переменное число аргументов

```py
def greet(name, age):
    print(f"Привет, {name}. Возраст: {age}")

info = {"name": "Ольга", "age": 25}
greet(**info)   # эквивалентно: greet(name="Ольга", age=25)
```


**Формальные параметры как словарь**
В примере kwargs — аргумент, который собирает все переданные именованные (keyword) аргументы, которые не были перечислены явно в заголовке функции. 

kwargs — словарь (dict). Имя `kwargs` = keyword arguments принято использовать для такого рода аргумента, но требований к имени нет.
```py
def show(**kwargs):
    for k, v in kwargs.items():
        print(k, "=", v)

show(a=1, b=2)
# или передать словарь
params = {"a": 1, "b": 2}
show(**params)
```

**Обычные аргументы и kwargs**
```py
def process(id, **features):
    print("id:", id)
    # features — словарь остальных признаков
    print("Признаков:", list(features.keys()))

process(10, height=180, weight=75)
# или
d = {"height": 180, "weight": 75}
process(10, **d)
```