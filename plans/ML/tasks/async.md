# Асинхронные запросы

**Цель**. Показать на практике, что в одном потоке асинхронный I/O-код может работать заметно быстрее синхронного при обработке большого числа сетевых запросов.

Реализовать две функции, которые будут выполнять HTTP запросы.

1. Синхронный код. Запросы выполняется последовательно/в цикле [в одном потоке], с единственным httpx.Client;
2. Асинхронный код. Запросы выполняются в одном потоке, используя asyncio + httpx.AsyncClient и asyncio.create_task / gather.

Измерить время выполнения каждой версии и проанализировать результат.

_Бонус: измерить время работы двух вариантов кода для разного количество запросов_

**Рекомендации**

- Используйте один и тот же список URL для обоих функций.
- Запустите каждую версию несколько раз (3–5) и возьмите медиану/среднее — чтобы нивелировать влияние случайных факторов.
- Выполняйте сравнение на одном и том же компьютере/сети, по возможности последовательно.
- Не делайте избыточно тяжёлых скачиваний — используйте мелкие ресурсы (HTML, JSON, маленькие картинки и т.п.).
- _Учитывайте возможную капчу/ограничения у серверов. Ставьте разумный лимит одновременных соединений (вариант с семафором)._

**Вопросы**

1. Что такое асинхронное выполнение?
1. Что такое цикл обработки событий? Можно ли без него выполнить асинхронный код? Как запустить этот цикл?
1. Что означает async? Await?
1. Что такое корутина? Что такое задача?
1. Как поставить задачи в очередь на выполнение?
1. В чем разница между параллелизмом и асинхронностью?
1. Когда асинхронный код будет быстрее обычного, синхронного? Когда разницы не будет?
1. Что такое GIL?
1. Когда стоит использовать параллельный алгоритм а когда асинхронный?
1. Будет ли скачивание больших объёмов данных (в одном запросе) так же эффективно в асинхронном коде?
